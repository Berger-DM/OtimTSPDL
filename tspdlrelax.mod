param v;
set V := 1..v;
set E, within V cross V;
var x{(i, j) in E}, binary;
var y{(i, j) in E}, >= 0;
param c{(i, j) in E};
set d;
set l;
minimize cost: sum{(i, j) in E} c[i, j] * x[i, j];
subject to predecessor: sum{(i, j) in E} x[i, j] = 1;
subject to sucessor: sum{(i, j) in E} x[i, j] = 1;
subject to atendimento: sum{i in V, j in 2..v} y[i, j] - sum{i in V, j in 2..v} y[j, i] = d[j];
subject to devidamente: sum{j in V} y[1, j] = sum{i in V} d[i];
subject to vazia: sum{i in V} y[i, 1] = 0;
subject to limites forall{i in V, j in V}: y[i, j] <= l[j] * x[i, j];
end;
